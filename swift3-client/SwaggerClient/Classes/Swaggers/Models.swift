// Models.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case HttpError(statusCode: Int, data: Data?, error: Error)
    case DecodeError(response: Data?, decodeError: DecodeError)
}

open class Response<T> {
    open let statusCode: Int
    open let header: [String: String]
    open let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for case let (key, value) as (String, String) in rawHeader {
            header[key] = value
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}

public enum Decoded<ValueType> {
    case success(ValueType)
    case failure(DecodeError)
}

public extension Decoded {
    var value: ValueType? {
        switch self {
        case let .success(value):
            return value
        case .failure:
            return nil
        }
    }
}

public enum DecodeError {
    case typeMismatch(expected: String, actual: String)
    case missingKey(key: String)
    case parseError(message: String)
}

private var once = Int()
class Decoders {
    static fileprivate var decoders = Dictionary<String, ((AnyObject, AnyObject?) -> AnyObject)>()

    static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> Decoded<T>)) {
        let key = "\(T.self)"
        decoders[key] = { decoder($0, $1) as AnyObject }
    }

    static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> Decoded<T> {
        let key = discriminator
        if let decoder = decoders[key], let value = decoder(source, nil) as? Decoded<T> {
            return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: [T].Type, source: AnyObject) -> Decoded<[T]> {
        if let sourceArray = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in sourceArray {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value):
                    values.append(value)
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        switch Decoders.decode(clazz: T.self, source: source, instance: nil) {
    	    case let .success(value):
                return .success(value)
            case let .failure(error):
                return .failure(error)
        }
    }

    static open func decode<T: RawRepresentable>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> Decoded<[Key:T]> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value):
                    dictionary[key] = value
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decodeOptional<T: RawRepresentable>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        guard !(source is NSNull), source != nil else { return .success(nil) }
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> Decoded<T> {
        initialize()
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int32.Type {
            return .success(value)
        }
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int64.Type {
     	    return .success(value)
        }
        if let intermediate = source as? String, let value = UUID(uuidString: intermediate) as? T, source is String, T.self is UUID.Type {
            return .success(value)
        }
        if let value = source as? T {
            return .success(value)
        }
        if let intermediate = source as? String, let value = Data(base64Encoded: intermediate) as? T {
            return .success(value)
        }

        let key = "\(T.self)"
        if let decoder = decoders[key], let value = decoder(source, instance) as? Decoded<T> {
           return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    //Convert a Decoded so that its value is optional. DO WE STILL NEED THIS?
    static func toOptional<T>(decoded: Decoded<T>) -> Decoded<T?> {
        return .success(decoded.value)
    }

    static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        if let source = source, !(source is NSNull) {
            switch Decoders.decode(clazz: clazz, source: source, instance: nil) {
            case let .success(value): return .success(value)
            case let .failure(error): return .failure(error)
            }
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> where T: RawRepresentable {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decodeOptional(clazz: T.self, source: sourceValue) {
                case let .success(value): if let value = value { values.append(value) }
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value): values.append(value)
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> Decoded<[Key:T]?> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value): dictionary[key] = value
                case let .failure(error): return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T: RawRepresentable, U: AnyObject>(clazz: T, source: AnyObject) -> Decoded<T?> where T.RawValue == U {
        if let value = source as? U {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "String", actual: String(describing: type(of: source))))
        }
    }


    private static var __once: () = {
        let formatters = [
            "yyyy-MM-dd",
            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSS",
            "yyyy-MM-dd HH:mm:ss"
        ].map { (format: String) -> DateFormatter in
            let formatter = DateFormatter()
            formatter.locale = Locale(identifier: "en_US_POSIX")
            formatter.dateFormat = format
            return formatter
        }
        // Decoder for Date
        Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Date> in
           if let sourceString = source as? String {
                for formatter in formatters {
                    if let date = formatter.date(from: sourceString) {
                        return .success(date)
                    }
                }
            }
            if let sourceInt = source as? Int {
                // treat as a java date
                return .success(Date(timeIntervalSince1970: Double(sourceInt / 1000) ))
            }
            if source is String || source is Int {
                return .failure(.parseError(message: "Could not decode date"))
            } else {
                return .failure(.typeMismatch(expected: "String or Int", actual: "\(source)"))
            }
        }

        // Decoder for ISOFullDate
        Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ISOFullDate> in
            if let string = source as? String,
               let isoDate = ISOFullDate.from(string: string) {
                return .success(isoDate)
            } else {
            	return .failure(.typeMismatch(expected: "ISO date", actual: "\(source)"))
            }
        }

        // Decoder for [ChannelName]
        Decoders.addDecoder(clazz: [ChannelName].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChannelName]> in
            return Decoders.decode(clazz: [ChannelName].self, source: source)
        }

        // Decoder for ChannelName
        Decoders.addDecoder(clazz: ChannelName.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChannelName> in
            if let source = source as? ChannelName {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias ChannelName", actual: "\(source)"))
            }
        }
        // Decoder for [EdgeModuleAddObject]
        Decoders.addDecoder(clazz: [EdgeModuleAddObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EdgeModuleAddObject]> in
            return Decoders.decode(clazz: [EdgeModuleAddObject].self, source: source)
        }

        // Decoder for EdgeModuleAddObject
        Decoders.addDecoder(clazz: EdgeModuleAddObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EdgeModuleAddObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
            var propsDictionary = sourceDictionary
            let keys : [AnyHashable] = ["modulename", "protocol", "protocolprops"]
                let _result = instance == nil ? EdgeModuleAddObject() : instance as! EdgeModuleAddObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modulename"] as AnyObject?) {
                
                case let .success(value): _result.modulename = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["protocol"] as AnyObject?) {
                
                case let .success(value): _result._protocol = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["protocolprops"] as AnyObject?) {
                
                case let .success(value): _result.protocolprops = value
                case let .failure(error): break
                
                }

                for key in keys {
                    propsDictionary.removeValue(forKey: key)
                }

                for key in propsDictionary.keys {
                    switch  Decoders.decodeOptional(clazz: String.self, source: propsDictionary[key] as AnyObject?) {

                    case let .success(value): _result[key] = value
                    default: continue

                    }
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EdgeModuleAddObject", actual: "\(source)"))
            }
        }
        // Decoder for [EdgeModuleAddedObject]
        Decoders.addDecoder(clazz: [EdgeModuleAddedObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EdgeModuleAddedObject]> in
            return Decoders.decode(clazz: [EdgeModuleAddedObject].self, source: source)
        }

        // Decoder for EdgeModuleAddedObject
        Decoders.addDecoder(clazz: EdgeModuleAddedObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EdgeModuleAddedObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EdgeModuleAddedObject() : instance as! EdgeModuleAddedObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modulename"] as AnyObject?) {
                
                case let .success(value): _result.modulename = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EdgeModuleAddedObject", actual: "\(source)"))
            }
        }
        // Decoder for [EdgeModuleObject]
        Decoders.addDecoder(clazz: [EdgeModuleObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EdgeModuleObject]> in
            return Decoders.decode(clazz: [EdgeModuleObject].self, source: source)
        }

        // Decoder for EdgeModuleObject
        Decoders.addDecoder(clazz: EdgeModuleObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EdgeModuleObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
            var propsDictionary = sourceDictionary
            let keys : [AnyHashable] = ["modulename", "_id", "protocol", "protocolprops", "_meta"]
                let _result = instance == nil ? EdgeModuleObject() : instance as! EdgeModuleObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modulename"] as AnyObject?) {
                
                case let .success(value): _result.modulename = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["protocol"] as AnyObject?) {
                
                case let .success(value): _result._protocol = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["protocolprops"] as AnyObject?) {
                
                case let .success(value): _result.protocolprops = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: MetaEdgeModuleObject.self, source: sourceDictionary["_meta"] as AnyObject?) {
                
                case let .success(value): _result.meta = value
                case let .failure(error): break
                
                }

                for key in keys {
                    propsDictionary.removeValue(forKey: key)
                }

                for key in propsDictionary.keys {
                    switch  Decoders.decodeOptional(clazz: String.self, source: propsDictionary[key] as AnyObject?) {

                    case let .success(value): _result[key] = value
                    default: continue

                    }
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EdgeModuleObject", actual: "\(source)"))
            }
        }
        // Decoder for [EdgeModuleResourceAddObject]
        Decoders.addDecoder(clazz: [EdgeModuleResourceAddObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EdgeModuleResourceAddObject]> in
            return Decoders.decode(clazz: [EdgeModuleResourceAddObject].self, source: source)
        }

        // Decoder for EdgeModuleResourceAddObject
        Decoders.addDecoder(clazz: EdgeModuleResourceAddObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EdgeModuleResourceAddObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
            var propsDictionary = sourceDictionary
            let keys : [AnyHashable] = ["resourcename"]
                let _result = instance == nil ? EdgeModuleResourceAddObject() : instance as! EdgeModuleResourceAddObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["resourcename"] as AnyObject?) {
                
                case let .success(value): _result.resourcename = value
                case let .failure(error): break
                
                }

                for key in keys {
                    propsDictionary.removeValue(forKey: key)
                }

                for key in propsDictionary.keys {
                    switch  Decoders.decodeOptional(clazz: String.self, source: propsDictionary[key] as AnyObject?) {

                    case let .success(value): _result[key] = value
                    default: continue

                    }
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EdgeModuleResourceAddObject", actual: "\(source)"))
            }
        }
        // Decoder for [EdgeModuleResourceAddedObject]
        Decoders.addDecoder(clazz: [EdgeModuleResourceAddedObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EdgeModuleResourceAddedObject]> in
            return Decoders.decode(clazz: [EdgeModuleResourceAddedObject].self, source: source)
        }

        // Decoder for EdgeModuleResourceAddedObject
        Decoders.addDecoder(clazz: EdgeModuleResourceAddedObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EdgeModuleResourceAddedObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EdgeModuleResourceAddedObject() : instance as! EdgeModuleResourceAddedObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["resourcename"] as AnyObject?) {
                
                case let .success(value): _result.resourcename = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EdgeModuleResourceAddedObject", actual: "\(source)"))
            }
        }
        // Decoder for [EdgeModuleResourceObject]
        Decoders.addDecoder(clazz: [EdgeModuleResourceObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EdgeModuleResourceObject]> in
            return Decoders.decode(clazz: [EdgeModuleResourceObject].self, source: source)
        }

        // Decoder for EdgeModuleResourceObject
        Decoders.addDecoder(clazz: EdgeModuleResourceObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EdgeModuleResourceObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
            var propsDictionary = sourceDictionary
            let keys : [AnyHashable] = ["resourcename", "modulename", "moduleid", "_meta"]
                let _result = instance == nil ? EdgeModuleResourceObject() : instance as! EdgeModuleResourceObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["resourcename"] as AnyObject?) {
                
                case let .success(value): _result.resourcename = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modulename"] as AnyObject?) {
                
                case let .success(value): _result.modulename = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["moduleid"] as AnyObject?) {
                
                case let .success(value): _result.moduleid = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: MetaEdgeModuleObject.self, source: sourceDictionary["_meta"] as AnyObject?) {
                
                case let .success(value): _result.meta = value
                case let .failure(error): break
                
                }

                for key in keys {
                    propsDictionary.removeValue(forKey: key)
                }

                for key in propsDictionary.keys {
                    switch  Decoders.decodeOptional(clazz: String.self, source: propsDictionary[key] as AnyObject?) {

                    case let .success(value): _result[key] = value
                    default: continue

                    }
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EdgeModuleResourceObject", actual: "\(source)"))
            }
        }
        // Decoder for [EdgeModuleResourceUpdateObject]
        Decoders.addDecoder(clazz: [EdgeModuleResourceUpdateObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EdgeModuleResourceUpdateObject]> in
            return Decoders.decode(clazz: [EdgeModuleResourceUpdateObject].self, source: source)
        }

        // Decoder for EdgeModuleResourceUpdateObject
        Decoders.addDecoder(clazz: EdgeModuleResourceUpdateObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EdgeModuleResourceUpdateObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
            var propsDictionary = sourceDictionary
            let keys : [AnyHashable] = ["resourcename"]
                let _result = instance == nil ? EdgeModuleResourceUpdateObject() : instance as! EdgeModuleResourceUpdateObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["resourcename"] as AnyObject?) {
                
                case let .success(value): _result.resourcename = value
                case let .failure(error): break
                
                }

                for key in keys {
                    propsDictionary.removeValue(forKey: key)
                }

                for key in propsDictionary.keys {
                    switch  Decoders.decodeOptional(clazz: String.self, source: propsDictionary[key] as AnyObject?) {

                    case let .success(value): _result[key] = value
                    default: continue

                    }
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EdgeModuleResourceUpdateObject", actual: "\(source)"))
            }
        }
        // Decoder for [EdgeModuleResourceUpdatedObject]
        Decoders.addDecoder(clazz: [EdgeModuleResourceUpdatedObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EdgeModuleResourceUpdatedObject]> in
            return Decoders.decode(clazz: [EdgeModuleResourceUpdatedObject].self, source: source)
        }

        // Decoder for EdgeModuleResourceUpdatedObject
        Decoders.addDecoder(clazz: EdgeModuleResourceUpdatedObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EdgeModuleResourceUpdatedObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EdgeModuleResourceUpdatedObject() : instance as! EdgeModuleResourceUpdatedObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EdgeModuleResourceUpdatedObject", actual: "\(source)"))
            }
        }
        // Decoder for [EdgeModuleUpdateObject]
        Decoders.addDecoder(clazz: [EdgeModuleUpdateObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EdgeModuleUpdateObject]> in
            return Decoders.decode(clazz: [EdgeModuleUpdateObject].self, source: source)
        }

        // Decoder for EdgeModuleUpdateObject
        Decoders.addDecoder(clazz: EdgeModuleUpdateObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EdgeModuleUpdateObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
            var propsDictionary = sourceDictionary
            let keys : [AnyHashable] = ["modulename", "protocol", "protocolprops"]
                let _result = instance == nil ? EdgeModuleUpdateObject() : instance as! EdgeModuleUpdateObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["modulename"] as AnyObject?) {
                
                case let .success(value): _result.modulename = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["protocol"] as AnyObject?) {
                
                case let .success(value): _result._protocol = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["protocolprops"] as AnyObject?) {
                
                case let .success(value): _result.protocolprops = value
                case let .failure(error): break
                
                }

                for key in keys {
                    propsDictionary.removeValue(forKey: key)
                }

                for key in propsDictionary.keys {
                    switch  Decoders.decodeOptional(clazz: String.self, source: propsDictionary[key] as AnyObject?) {

                    case let .success(value): _result[key] = value
                    default: continue

                    }
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EdgeModuleUpdateObject", actual: "\(source)"))
            }
        }
        // Decoder for [EdgeModuleUpdatedObject]
        Decoders.addDecoder(clazz: [EdgeModuleUpdatedObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EdgeModuleUpdatedObject]> in
            return Decoders.decode(clazz: [EdgeModuleUpdatedObject].self, source: source)
        }

        // Decoder for EdgeModuleUpdatedObject
        Decoders.addDecoder(clazz: EdgeModuleUpdatedObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EdgeModuleUpdatedObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EdgeModuleUpdatedObject() : instance as! EdgeModuleUpdatedObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EdgeModuleUpdatedObject", actual: "\(source)"))
            }
        }
        // Decoder for [FieldGroupObject]
        Decoders.addDecoder(clazz: [FieldGroupObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldGroupObject]> in
            return Decoders.decode(clazz: [FieldGroupObject].self, source: source)
        }

        // Decoder for FieldGroupObject
        Decoders.addDecoder(clazz: FieldGroupObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldGroupObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldGroupObject() : instance as! FieldGroupObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [FieldObjectFields].self, source: sourceDictionary["fields"] as AnyObject?) {
                
                case let .success(value): _result.fields = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["custom"] as AnyObject?) {
                
                case let .success(value): _result.custom = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldGroupObject", actual: "\(source)"))
            }
        }
        // Decoder for [FieldInstallationObject]
        Decoders.addDecoder(clazz: [FieldInstallationObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldInstallationObject]> in
            return Decoders.decode(clazz: [FieldInstallationObject].self, source: source)
        }

        // Decoder for FieldInstallationObject
        Decoders.addDecoder(clazz: FieldInstallationObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldInstallationObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldInstallationObject() : instance as! FieldInstallationObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [FieldObjectFields].self, source: sourceDictionary["fields"] as AnyObject?) {
                
                case let .success(value): _result.fields = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["custom"] as AnyObject?) {
                
                case let .success(value): _result.custom = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldInstallationObject", actual: "\(source)"))
            }
        }
        // Decoder for [FieldObject]
        Decoders.addDecoder(clazz: [FieldObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldObject]> in
            return Decoders.decode(clazz: [FieldObject].self, source: source)
        }

        // Decoder for FieldObject
        Decoders.addDecoder(clazz: FieldObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldObject() : instance as! FieldObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [FieldObjectFields].self, source: sourceDictionary["fields"] as AnyObject?) {
                
                case let .success(value): _result.fields = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["custom"] as AnyObject?) {
                
                case let .success(value): _result.custom = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldObject", actual: "\(source)"))
            }
        }
        // Decoder for [FieldObjectFields]
        Decoders.addDecoder(clazz: [FieldObjectFields].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldObjectFields]> in
            return Decoders.decode(clazz: [FieldObjectFields].self, source: source)
        }

        // Decoder for FieldObjectFields
        Decoders.addDecoder(clazz: FieldObjectFields.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldObjectFields> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldObjectFields() : instance as! FieldObjectFields
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldObjectFields", actual: "\(source)"))
            }
        }
        // Decoder for [FieldsEdgeModuleObject]
        Decoders.addDecoder(clazz: [FieldsEdgeModuleObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FieldsEdgeModuleObject]> in
            return Decoders.decode(clazz: [FieldsEdgeModuleObject].self, source: source)
        }

        // Decoder for FieldsEdgeModuleObject
        Decoders.addDecoder(clazz: FieldsEdgeModuleObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FieldsEdgeModuleObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FieldsEdgeModuleObject() : instance as! FieldsEdgeModuleObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [FieldObjectFields].self, source: sourceDictionary["fields"] as AnyObject?) {
                
                case let .success(value): _result.fields = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["custom"] as AnyObject?) {
                
                case let .success(value): _result.custom = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FieldsEdgeModuleObject", actual: "\(source)"))
            }
        }
        // Decoder for [GroupAddObject]
        Decoders.addDecoder(clazz: [GroupAddObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GroupAddObject]> in
            return Decoders.decode(clazz: [GroupAddObject].self, source: source)
        }

        // Decoder for GroupAddObject
        Decoders.addDecoder(clazz: GroupAddObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GroupAddObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GroupAddObject() : instance as! GroupAddObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["groupname"] as AnyObject?) {
                
                case let .success(value): _result.groupname = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GroupAddObject", actual: "\(source)"))
            }
        }
        // Decoder for [GroupName]
        Decoders.addDecoder(clazz: [GroupName].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GroupName]> in
            return Decoders.decode(clazz: [GroupName].self, source: source)
        }

        // Decoder for GroupName
        Decoders.addDecoder(clazz: GroupName.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GroupName> in
            if let source = source as? GroupName {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias GroupName", actual: "\(source)"))
            }
        }
        // Decoder for [GroupObject]
        Decoders.addDecoder(clazz: [GroupObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GroupObject]> in
            return Decoders.decode(clazz: [GroupObject].self, source: source)
        }

        // Decoder for GroupObject
        Decoders.addDecoder(clazz: GroupObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GroupObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
            var propsDictionary = sourceDictionary
            let keys : [AnyHashable] = ["name", "_meta", "users"]
                let _result = instance == nil ? GroupObject() : instance as! GroupObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: MetaGroupObject.self, source: sourceDictionary["_meta"] as AnyObject?) {
                
                case let .success(value): _result.meta = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["users"] as AnyObject?) {
                
                case let .success(value): _result.users = value
                case let .failure(error): break
                
                }

                for key in keys {
                    propsDictionary.removeValue(forKey: key)
                }

                for key in propsDictionary.keys {
                    switch  Decoders.decodeOptional(clazz: String.self, source: propsDictionary[key] as AnyObject?) {

                    case let .success(value): _result[key] = value
                    default: continue

                    }
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GroupObject", actual: "\(source)"))
            }
        }
        // Decoder for [InstallationAddObject]
        Decoders.addDecoder(clazz: [InstallationAddObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InstallationAddObject]> in
            return Decoders.decode(clazz: [InstallationAddObject].self, source: source)
        }

        // Decoder for InstallationAddObject
        Decoders.addDecoder(clazz: InstallationAddObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InstallationAddObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
            var propsDictionary = sourceDictionary
            let keys : [AnyHashable] = ["deviceToken", "deviceType", "channels"]
                let _result = instance == nil ? InstallationAddObject() : instance as! InstallationAddObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["deviceToken"] as AnyObject?) {
                
                case let .success(value): _result.deviceToken = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["deviceType"] as AnyObject?) {
                
                case let .success(value): _result.deviceType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["channels"] as AnyObject?) {
                
                case let .success(value): _result.channels = value
                case let .failure(error): break
                
                }

                for key in keys {
                    propsDictionary.removeValue(forKey: key)
                }

                for key in propsDictionary.keys {
                    switch  Decoders.decodeOptional(clazz: String.self, source: propsDictionary[key] as AnyObject?) {

                    case let .success(value): _result[key] = value
                    default: continue

                    }
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InstallationAddObject", actual: "\(source)"))
            }
        }
        // Decoder for [InstallationAddedObject]
        Decoders.addDecoder(clazz: [InstallationAddedObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InstallationAddedObject]> in
            return Decoders.decode(clazz: [InstallationAddedObject].self, source: source)
        }

        // Decoder for InstallationAddedObject
        Decoders.addDecoder(clazz: InstallationAddedObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InstallationAddedObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InstallationAddedObject() : instance as! InstallationAddedObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InstallationAddedObject", actual: "\(source)"))
            }
        }
        // Decoder for [InstallationObject]
        Decoders.addDecoder(clazz: [InstallationObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InstallationObject]> in
            return Decoders.decode(clazz: [InstallationObject].self, source: source)
        }

        // Decoder for InstallationObject
        Decoders.addDecoder(clazz: InstallationObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InstallationObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
            var propsDictionary = sourceDictionary
            let keys : [AnyHashable] = ["_id", "deviceToken", "deviceType", "_meta", "channels"]
                let _result = instance == nil ? InstallationObject() : instance as! InstallationObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["deviceToken"] as AnyObject?) {
                
                case let .success(value): _result.deviceToken = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: InstallationObject.DeviceType.self, source: sourceDictionary["deviceType"] as AnyObject?) {
                
                case let .success(value): _result.deviceType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: MetaInstallationObject.self, source: sourceDictionary["_meta"] as AnyObject?) {
                
                case let .success(value): _result.meta = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["channels"] as AnyObject?) {
                
                case let .success(value): _result.channels = value
                case let .failure(error): break
                
                }

                for key in keys {
                    propsDictionary.removeValue(forKey: key)
                }

                for key in propsDictionary.keys {
                    switch  Decoders.decodeOptional(clazz: String.self, source: propsDictionary[key] as AnyObject?) {

                    case let .success(value): _result[key] = value
                    default: continue

                    }
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InstallationObject", actual: "\(source)"))
            }
        }
        // Decoder for [MetaEdgeModuleObject]
        Decoders.addDecoder(clazz: [MetaEdgeModuleObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MetaEdgeModuleObject]> in
            return Decoders.decode(clazz: [MetaEdgeModuleObject].self, source: source)
        }

        // Decoder for MetaEdgeModuleObject
        Decoders.addDecoder(clazz: MetaEdgeModuleObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MetaEdgeModuleObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? MetaEdgeModuleObject() : instance as! MetaEdgeModuleObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["creator"] as AnyObject?) {
                
                case let .success(value): _result.creator = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "MetaEdgeModuleObject", actual: "\(source)"))
            }
        }
        // Decoder for [MetaGroupObject]
        Decoders.addDecoder(clazz: [MetaGroupObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MetaGroupObject]> in
            return Decoders.decode(clazz: [MetaGroupObject].self, source: source)
        }

        // Decoder for MetaGroupObject
        Decoders.addDecoder(clazz: MetaGroupObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MetaGroupObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? MetaGroupObject() : instance as! MetaGroupObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["creator"] as AnyObject?) {
                
                case let .success(value): _result.creator = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "MetaGroupObject", actual: "\(source)"))
            }
        }
        // Decoder for [MetaInstallationObject]
        Decoders.addDecoder(clazz: [MetaInstallationObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MetaInstallationObject]> in
            return Decoders.decode(clazz: [MetaInstallationObject].self, source: source)
        }

        // Decoder for MetaInstallationObject
        Decoders.addDecoder(clazz: MetaInstallationObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MetaInstallationObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? MetaInstallationObject() : instance as! MetaInstallationObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["creator"] as AnyObject?) {
                
                case let .success(value): _result.creator = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "MetaInstallationObject", actual: "\(source)"))
            }
        }
        // Decoder for [MetaObject]
        Decoders.addDecoder(clazz: [MetaObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MetaObject]> in
            return Decoders.decode(clazz: [MetaObject].self, source: source)
        }

        // Decoder for MetaObject
        Decoders.addDecoder(clazz: MetaObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MetaObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? MetaObject() : instance as! MetaObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["creator"] as AnyObject?) {
                
                case let .success(value): _result.creator = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "MetaObject", actual: "\(source)"))
            }
        }
        // Decoder for [PushDataObject]
        Decoders.addDecoder(clazz: [PushDataObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PushDataObject]> in
            return Decoders.decode(clazz: [PushDataObject].self, source: source)
        }

        // Decoder for PushDataObject
        Decoders.addDecoder(clazz: PushDataObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PushDataObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PushDataObject() : instance as! PushDataObject
                switch Decoders.decodeOptional(clazz: PushDataObjectGcm.self, source: sourceDictionary["gcm"] as AnyObject?) {
                
                case let .success(value): _result.gcm = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PushDataObjectAps.self, source: sourceDictionary["aps"] as AnyObject?) {
                
                case let .success(value): _result.aps = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PushDataObjectExtras.self, source: sourceDictionary["extras"] as AnyObject?) {
                
                case let .success(value): _result.extras = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PushDataObject", actual: "\(source)"))
            }
        }
        // Decoder for [PushDataObjectAps]
        Decoders.addDecoder(clazz: [PushDataObjectAps].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PushDataObjectAps]> in
            return Decoders.decode(clazz: [PushDataObjectAps].self, source: source)
        }

        // Decoder for PushDataObjectAps
        Decoders.addDecoder(clazz: PushDataObjectAps.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PushDataObjectAps> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PushDataObjectAps() : instance as! PushDataObjectAps
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["alert"] as AnyObject?) {
                
                case let .success(value): _result.alert = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["badge"] as AnyObject?) {
                
                case let .success(value): _result.badge = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sound"] as AnyObject?) {
                
                case let .success(value): _result.sound = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PushDataObjectAps", actual: "\(source)"))
            }
        }
        // Decoder for [PushDataObjectExtras]
        Decoders.addDecoder(clazz: [PushDataObjectExtras].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PushDataObjectExtras]> in
            return Decoders.decode(clazz: [PushDataObjectExtras].self, source: source)
        }

        // Decoder for PushDataObjectExtras
        Decoders.addDecoder(clazz: PushDataObjectExtras.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PushDataObjectExtras> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PushDataObjectExtras() : instance as! PushDataObjectExtras
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PushDataObjectExtras", actual: "\(source)"))
            }
        }
        // Decoder for [PushDataObjectGcm]
        Decoders.addDecoder(clazz: [PushDataObjectGcm].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PushDataObjectGcm]> in
            return Decoders.decode(clazz: [PushDataObjectGcm].self, source: source)
        }

        // Decoder for PushDataObjectGcm
        Decoders.addDecoder(clazz: PushDataObjectGcm.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PushDataObjectGcm> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PushDataObjectGcm() : instance as! PushDataObjectGcm
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PushDataObjectGcm", actual: "\(source)"))
            }
        }
        // Decoder for [PushObject]
        Decoders.addDecoder(clazz: [PushObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PushObject]> in
            return Decoders.decode(clazz: [PushObject].self, source: source)
        }

        // Decoder for PushObject
        Decoders.addDecoder(clazz: PushObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PushObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PushObject() : instance as! PushObject
                switch Decoders.decodeOptional(clazz: PushDataObject.self, source: sourceDictionary["data"] as AnyObject?) {
                
                case let .success(value): _result.data = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["channels"] as AnyObject?) {
                
                case let .success(value): _result.channels = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PushWhereObject.self, source: sourceDictionary["where"] as AnyObject?) {
                
                case let .success(value): _result._where = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PushObject", actual: "\(source)"))
            }
        }
        // Decoder for [PushWhereObject]
        Decoders.addDecoder(clazz: [PushWhereObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PushWhereObject]> in
            return Decoders.decode(clazz: [PushWhereObject].self, source: source)
        }

        // Decoder for PushWhereObject
        Decoders.addDecoder(clazz: PushWhereObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PushWhereObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PushWhereObject() : instance as! PushWhereObject
                switch Decoders.decodeOptional(clazz: PushWhereObject.DeviceType.self, source: sourceDictionary["deviceType"] as AnyObject?) {
                
                case let .success(value): _result.deviceType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PushWhereObjectDeviceToken.self, source: sourceDictionary["deviceToken"] as AnyObject?) {
                
                case let .success(value): _result.deviceToken = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PushWhereObject", actual: "\(source)"))
            }
        }
        // Decoder for [PushWhereObjectDeviceToken]
        Decoders.addDecoder(clazz: [PushWhereObjectDeviceToken].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PushWhereObjectDeviceToken]> in
            return Decoders.decode(clazz: [PushWhereObjectDeviceToken].self, source: source)
        }

        // Decoder for PushWhereObjectDeviceToken
        Decoders.addDecoder(clazz: PushWhereObjectDeviceToken.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PushWhereObjectDeviceToken> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PushWhereObjectDeviceToken() : instance as! PushWhereObjectDeviceToken
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["$in"] as AnyObject?) {
                
                case let .success(value): _result._in = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PushWhereObjectDeviceToken", actual: "\(source)"))
            }
        }
        // Decoder for [UpdateGroupObject]
        Decoders.addDecoder(clazz: [UpdateGroupObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UpdateGroupObject]> in
            return Decoders.decode(clazz: [UpdateGroupObject].self, source: source)
        }

        // Decoder for UpdateGroupObject
        Decoders.addDecoder(clazz: UpdateGroupObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UpdateGroupObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UpdateGroupObject() : instance as! UpdateGroupObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fieldName"] as AnyObject?) {
                
                case let .success(value): _result.fieldName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["users"] as AnyObject?) {
                
                case let .success(value): _result.users = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UpdateGroupObject", actual: "\(source)"))
            }
        }
        // Decoder for [UpdateInstallationObject]
        Decoders.addDecoder(clazz: [UpdateInstallationObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UpdateInstallationObject]> in
            return Decoders.decode(clazz: [UpdateInstallationObject].self, source: source)
        }

        // Decoder for UpdateInstallationObject
        Decoders.addDecoder(clazz: UpdateInstallationObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UpdateInstallationObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
            var propsDictionary = sourceDictionary
            let keys : [AnyHashable] = ["channels"]
                let _result = instance == nil ? UpdateInstallationObject() : instance as! UpdateInstallationObject
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["channels"] as AnyObject?) {
                
                case let .success(value): _result.channels = value
                case let .failure(error): break
                
                }

                for key in keys {
                    propsDictionary.removeValue(forKey: key)
                }

                for key in propsDictionary.keys {
                    switch  Decoders.decodeOptional(clazz: String.self, source: propsDictionary[key] as AnyObject?) {

                    case let .success(value): _result[key] = value
                    default: continue

                    }
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UpdateInstallationObject", actual: "\(source)"))
            }
        }
        // Decoder for [UpdateObject]
        Decoders.addDecoder(clazz: [UpdateObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UpdateObject]> in
            return Decoders.decode(clazz: [UpdateObject].self, source: source)
        }

        // Decoder for UpdateObject
        Decoders.addDecoder(clazz: UpdateObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UpdateObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UpdateObject() : instance as! UpdateObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fieldName"] as AnyObject?) {
                
                case let .success(value): _result.fieldName = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UpdateObject", actual: "\(source)"))
            }
        }
        // Decoder for [UpdatedGroupObject]
        Decoders.addDecoder(clazz: [UpdatedGroupObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UpdatedGroupObject]> in
            return Decoders.decode(clazz: [UpdatedGroupObject].self, source: source)
        }

        // Decoder for UpdatedGroupObject
        Decoders.addDecoder(clazz: UpdatedGroupObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UpdatedGroupObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UpdatedGroupObject() : instance as! UpdatedGroupObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UpdatedGroupObject", actual: "\(source)"))
            }
        }
        // Decoder for [UpdatedInstallationObject]
        Decoders.addDecoder(clazz: [UpdatedInstallationObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UpdatedInstallationObject]> in
            return Decoders.decode(clazz: [UpdatedInstallationObject].self, source: source)
        }

        // Decoder for UpdatedInstallationObject
        Decoders.addDecoder(clazz: UpdatedInstallationObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UpdatedInstallationObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UpdatedInstallationObject() : instance as! UpdatedInstallationObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UpdatedInstallationObject", actual: "\(source)"))
            }
        }
        // Decoder for [UpdatedObject]
        Decoders.addDecoder(clazz: [UpdatedObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UpdatedObject]> in
            return Decoders.decode(clazz: [UpdatedObject].self, source: source)
        }

        // Decoder for UpdatedObject
        Decoders.addDecoder(clazz: UpdatedObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UpdatedObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UpdatedObject() : instance as! UpdatedObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UpdatedObject", actual: "\(source)"))
            }
        }
        // Decoder for [UserCredentialsObject]
        Decoders.addDecoder(clazz: [UserCredentialsObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserCredentialsObject]> in
            return Decoders.decode(clazz: [UserCredentialsObject].self, source: source)
        }

        // Decoder for UserCredentialsObject
        Decoders.addDecoder(clazz: UserCredentialsObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserCredentialsObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserCredentialsObject() : instance as! UserCredentialsObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): _result.username = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                
                case let .success(value): _result.password = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserCredentialsObject", actual: "\(source)"))
            }
        }
        // Decoder for [UserObject]
        Decoders.addDecoder(clazz: [UserObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserObject]> in
            return Decoders.decode(clazz: [UserObject].self, source: source)
        }

        // Decoder for UserObject
        Decoders.addDecoder(clazz: UserObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
            var propsDictionary = sourceDictionary
            let keys : [AnyHashable] = ["id", "username", "_meta"]
                let _result = instance == nil ? UserObject() : instance as! UserObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): _result.username = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: MetaObject.self, source: sourceDictionary["_meta"] as AnyObject?) {
                
                case let .success(value): _result.meta = value
                case let .failure(error): break
                
                }

                for key in keys {
                    propsDictionary.removeValue(forKey: key)
                }

                for key in propsDictionary.keys {
                    switch  Decoders.decodeOptional(clazz: String.self, source: propsDictionary[key] as AnyObject?) {

                    case let .success(value): _result[key] = value
                    default: continue

                    }
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserObject", actual: "\(source)"))
            }
        }
        // Decoder for [UserSignUpResponseObject]
        Decoders.addDecoder(clazz: [UserSignUpResponseObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserSignUpResponseObject]> in
            return Decoders.decode(clazz: [UserSignUpResponseObject].self, source: source)
        }

        // Decoder for UserSignUpResponseObject
        Decoders.addDecoder(clazz: UserSignUpResponseObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserSignUpResponseObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserSignUpResponseObject() : instance as! UserSignUpResponseObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sessionToken"] as AnyObject?) {
                
                case let .success(value): _result.sessionToken = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserSignUpResponseObject", actual: "\(source)"))
            }
        }
        // Decoder for [UserTokenObject]
        Decoders.addDecoder(clazz: [UserTokenObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserTokenObject]> in
            return Decoders.decode(clazz: [UserTokenObject].self, source: source)
        }

        // Decoder for UserTokenObject
        Decoders.addDecoder(clazz: UserTokenObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserTokenObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserTokenObject() : instance as! UserTokenObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): _result.username = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: MetaObject.self, source: sourceDictionary["_meta"] as AnyObject?) {
                
                case let .success(value): _result.meta = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sessiontoken"] as AnyObject?) {
                
                case let .success(value): _result.sessiontoken = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserTokenObject", actual: "\(source)"))
            }
        }
        // Decoder for [UseridObject]
        Decoders.addDecoder(clazz: [UseridObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UseridObject]> in
            return Decoders.decode(clazz: [UseridObject].self, source: source)
        }

        // Decoder for UseridObject
        Decoders.addDecoder(clazz: UseridObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UseridObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UseridObject() : instance as! UseridObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UseridObject", actual: "\(source)"))
            }
        }
        // Decoder for [VersionObject]
        Decoders.addDecoder(clazz: [VersionObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VersionObject]> in
            return Decoders.decode(clazz: [VersionObject].self, source: source)
        }

        // Decoder for VersionObject
        Decoders.addDecoder(clazz: VersionObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VersionObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VersionObject() : instance as! VersionObject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                
                case let .success(value): _result.version = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["server"] as AnyObject?) {
                
                case let .success(value): _result.server = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VersionObject", actual: "\(source)"))
            }
        }
    }()

    static fileprivate func initialize() {
        _ = Decoders.__once
    }
}
