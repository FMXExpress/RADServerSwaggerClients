{-
   EMS API Documentation

   Enterprise Mobility Services API      [Learn about EMS](https://www.embarcadero.com/products/rad-studio/enterprise-mobility-services)      EMS (Enterprise Mobility Services) offers a Mobile Enterprise Application Platform (MEAP)      TurnKey Middleware for Interconnected Distributed Apps

   OpenAPI spec version: 2.0
   EMS API Documentation API version: 0.0.0
   Generated by Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
-}

{-|
Module : EMSAPIDocumentation.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module EMSAPIDocumentation.Model where

import EMSAPIDocumentation.Core
import EMSAPIDocumentation.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Id
newtype Id = Id { unId :: Text } deriving (P.Eq, P.Show)

-- ** Item
newtype Item = Item { unItem :: Text } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Double } deriving (P.Eq, P.Show)

-- ** Mname
newtype Mname = Mname { unMname :: Text } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** Order
newtype Order = Order { unOrder :: Double } deriving (P.Eq, P.Show)

-- ** ParamWhere
newtype ParamWhere = ParamWhere { unParamWhere :: Text } deriving (P.Eq, P.Show)

-- ** Rname
newtype Rname = Rname { unRname :: Text } deriving (P.Eq, P.Show)

-- ** Skip
newtype Skip = Skip { unSkip :: Double } deriving (P.Eq, P.Show)

-- ** Wildcard
newtype Wildcard = Wildcard { unWildcard :: Text } deriving (P.Eq, P.Show)

-- ** XEmbarcaderoAppSecret
newtype XEmbarcaderoAppSecret = XEmbarcaderoAppSecret { unXEmbarcaderoAppSecret :: Text } deriving (P.Eq, P.Show)

-- ** XEmbarcaderoApplicationId
newtype XEmbarcaderoApplicationId = XEmbarcaderoApplicationId { unXEmbarcaderoApplicationId :: Text } deriving (P.Eq, P.Show)

-- ** XEmbarcaderoMasterSecret
newtype XEmbarcaderoMasterSecret = XEmbarcaderoMasterSecret { unXEmbarcaderoMasterSecret :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** ChannelName
-- | ChannelName
newtype ChannelName = ChannelName
  { unChannelName :: Text
  } deriving (P.Eq, P.Show, P.Typeable, A.ToJSON, A.FromJSON, WH.ToHttpApiData, WH.FromHttpApiData)


-- ** EdgeModuleAddObject
-- | EdgeModuleAddObject
data EdgeModuleAddObject = EdgeModuleAddObject
  { edgeModuleAddObjectModulename :: !(Text) -- ^ /Required/ "modulename"
  , edgeModuleAddObjectProtocol :: !(Text) -- ^ /Required/ "protocol"
  , edgeModuleAddObjectProtocolprops :: !(Text) -- ^ /Required/ "protocolprops"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EdgeModuleAddObject
instance A.FromJSON EdgeModuleAddObject where
  parseJSON = A.withObject "EdgeModuleAddObject" $ \o ->
    EdgeModuleAddObject
      <$> (o .:  "modulename")
      <*> (o .:  "protocol")
      <*> (o .:  "protocolprops")

-- | ToJSON EdgeModuleAddObject
instance A.ToJSON EdgeModuleAddObject where
  toJSON EdgeModuleAddObject {..} =
   _omitNulls
      [ "modulename" .= edgeModuleAddObjectModulename
      , "protocol" .= edgeModuleAddObjectProtocol
      , "protocolprops" .= edgeModuleAddObjectProtocolprops
      ]


-- | Construct a value of type 'EdgeModuleAddObject' (by applying it's required fields, if any)
mkEdgeModuleAddObject
  :: Text -- ^ 'edgeModuleAddObjectModulename' 
  -> Text -- ^ 'edgeModuleAddObjectProtocol' 
  -> Text -- ^ 'edgeModuleAddObjectProtocolprops' 
  -> EdgeModuleAddObject
mkEdgeModuleAddObject edgeModuleAddObjectModulename edgeModuleAddObjectProtocol edgeModuleAddObjectProtocolprops =
  EdgeModuleAddObject
  { edgeModuleAddObjectModulename
  , edgeModuleAddObjectProtocol
  , edgeModuleAddObjectProtocolprops
  }

-- ** EdgeModuleAddedObject
-- | EdgeModuleAddedObject
data EdgeModuleAddedObject = EdgeModuleAddedObject
  { edgeModuleAddedObjectId :: !(Text) -- ^ /Required/ "_id"
  , edgeModuleAddedObjectModulename :: !(Text) -- ^ /Required/ "modulename"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EdgeModuleAddedObject
instance A.FromJSON EdgeModuleAddedObject where
  parseJSON = A.withObject "EdgeModuleAddedObject" $ \o ->
    EdgeModuleAddedObject
      <$> (o .:  "_id")
      <*> (o .:  "modulename")

-- | ToJSON EdgeModuleAddedObject
instance A.ToJSON EdgeModuleAddedObject where
  toJSON EdgeModuleAddedObject {..} =
   _omitNulls
      [ "_id" .= edgeModuleAddedObjectId
      , "modulename" .= edgeModuleAddedObjectModulename
      ]


-- | Construct a value of type 'EdgeModuleAddedObject' (by applying it's required fields, if any)
mkEdgeModuleAddedObject
  :: Text -- ^ 'edgeModuleAddedObjectId' 
  -> Text -- ^ 'edgeModuleAddedObjectModulename' 
  -> EdgeModuleAddedObject
mkEdgeModuleAddedObject edgeModuleAddedObjectId edgeModuleAddedObjectModulename =
  EdgeModuleAddedObject
  { edgeModuleAddedObjectId
  , edgeModuleAddedObjectModulename
  }

-- ** EdgeModuleObject
-- | EdgeModuleObject
data EdgeModuleObject = EdgeModuleObject
  { edgeModuleObjectModulename :: !(Text) -- ^ /Required/ "modulename"
  , edgeModuleObjectId :: !(Text) -- ^ /Required/ "_id"
  , edgeModuleObjectProtocol :: !(Text) -- ^ /Required/ "protocol"
  , edgeModuleObjectProtocolprops :: !(Text) -- ^ /Required/ "protocolprops"
  , edgeModuleObjectMeta :: !(MetaEdgeModuleObject) -- ^ /Required/ "_meta"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EdgeModuleObject
instance A.FromJSON EdgeModuleObject where
  parseJSON = A.withObject "EdgeModuleObject" $ \o ->
    EdgeModuleObject
      <$> (o .:  "modulename")
      <*> (o .:  "_id")
      <*> (o .:  "protocol")
      <*> (o .:  "protocolprops")
      <*> (o .:  "_meta")

-- | ToJSON EdgeModuleObject
instance A.ToJSON EdgeModuleObject where
  toJSON EdgeModuleObject {..} =
   _omitNulls
      [ "modulename" .= edgeModuleObjectModulename
      , "_id" .= edgeModuleObjectId
      , "protocol" .= edgeModuleObjectProtocol
      , "protocolprops" .= edgeModuleObjectProtocolprops
      , "_meta" .= edgeModuleObjectMeta
      ]


-- | Construct a value of type 'EdgeModuleObject' (by applying it's required fields, if any)
mkEdgeModuleObject
  :: Text -- ^ 'edgeModuleObjectModulename' 
  -> Text -- ^ 'edgeModuleObjectId' 
  -> Text -- ^ 'edgeModuleObjectProtocol' 
  -> Text -- ^ 'edgeModuleObjectProtocolprops' 
  -> MetaEdgeModuleObject -- ^ 'edgeModuleObjectMeta' 
  -> EdgeModuleObject
mkEdgeModuleObject edgeModuleObjectModulename edgeModuleObjectId edgeModuleObjectProtocol edgeModuleObjectProtocolprops edgeModuleObjectMeta =
  EdgeModuleObject
  { edgeModuleObjectModulename
  , edgeModuleObjectId
  , edgeModuleObjectProtocol
  , edgeModuleObjectProtocolprops
  , edgeModuleObjectMeta
  }

-- ** EdgeModuleResourceAddObject
-- | EdgeModuleResourceAddObject
data EdgeModuleResourceAddObject = EdgeModuleResourceAddObject
  { edgeModuleResourceAddObjectResourcename :: !(Text) -- ^ /Required/ "resourcename"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EdgeModuleResourceAddObject
instance A.FromJSON EdgeModuleResourceAddObject where
  parseJSON = A.withObject "EdgeModuleResourceAddObject" $ \o ->
    EdgeModuleResourceAddObject
      <$> (o .:  "resourcename")

-- | ToJSON EdgeModuleResourceAddObject
instance A.ToJSON EdgeModuleResourceAddObject where
  toJSON EdgeModuleResourceAddObject {..} =
   _omitNulls
      [ "resourcename" .= edgeModuleResourceAddObjectResourcename
      ]


-- | Construct a value of type 'EdgeModuleResourceAddObject' (by applying it's required fields, if any)
mkEdgeModuleResourceAddObject
  :: Text -- ^ 'edgeModuleResourceAddObjectResourcename' 
  -> EdgeModuleResourceAddObject
mkEdgeModuleResourceAddObject edgeModuleResourceAddObjectResourcename =
  EdgeModuleResourceAddObject
  { edgeModuleResourceAddObjectResourcename
  }

-- ** EdgeModuleResourceAddedObject
-- | EdgeModuleResourceAddedObject
data EdgeModuleResourceAddedObject = EdgeModuleResourceAddedObject
  { edgeModuleResourceAddedObjectResourcename :: !(Text) -- ^ /Required/ "resourcename"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EdgeModuleResourceAddedObject
instance A.FromJSON EdgeModuleResourceAddedObject where
  parseJSON = A.withObject "EdgeModuleResourceAddedObject" $ \o ->
    EdgeModuleResourceAddedObject
      <$> (o .:  "resourcename")

-- | ToJSON EdgeModuleResourceAddedObject
instance A.ToJSON EdgeModuleResourceAddedObject where
  toJSON EdgeModuleResourceAddedObject {..} =
   _omitNulls
      [ "resourcename" .= edgeModuleResourceAddedObjectResourcename
      ]


-- | Construct a value of type 'EdgeModuleResourceAddedObject' (by applying it's required fields, if any)
mkEdgeModuleResourceAddedObject
  :: Text -- ^ 'edgeModuleResourceAddedObjectResourcename' 
  -> EdgeModuleResourceAddedObject
mkEdgeModuleResourceAddedObject edgeModuleResourceAddedObjectResourcename =
  EdgeModuleResourceAddedObject
  { edgeModuleResourceAddedObjectResourcename
  }

-- ** EdgeModuleResourceObject
-- | EdgeModuleResourceObject
data EdgeModuleResourceObject = EdgeModuleResourceObject
  { edgeModuleResourceObjectResourcename :: !(Text) -- ^ /Required/ "resourcename"
  , edgeModuleResourceObjectModulename :: !(Text) -- ^ /Required/ "modulename"
  , edgeModuleResourceObjectModuleid :: !(Text) -- ^ /Required/ "moduleid"
  , edgeModuleResourceObjectMeta :: !(MetaEdgeModuleObject) -- ^ /Required/ "_meta"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EdgeModuleResourceObject
instance A.FromJSON EdgeModuleResourceObject where
  parseJSON = A.withObject "EdgeModuleResourceObject" $ \o ->
    EdgeModuleResourceObject
      <$> (o .:  "resourcename")
      <*> (o .:  "modulename")
      <*> (o .:  "moduleid")
      <*> (o .:  "_meta")

-- | ToJSON EdgeModuleResourceObject
instance A.ToJSON EdgeModuleResourceObject where
  toJSON EdgeModuleResourceObject {..} =
   _omitNulls
      [ "resourcename" .= edgeModuleResourceObjectResourcename
      , "modulename" .= edgeModuleResourceObjectModulename
      , "moduleid" .= edgeModuleResourceObjectModuleid
      , "_meta" .= edgeModuleResourceObjectMeta
      ]


-- | Construct a value of type 'EdgeModuleResourceObject' (by applying it's required fields, if any)
mkEdgeModuleResourceObject
  :: Text -- ^ 'edgeModuleResourceObjectResourcename' 
  -> Text -- ^ 'edgeModuleResourceObjectModulename' 
  -> Text -- ^ 'edgeModuleResourceObjectModuleid' 
  -> MetaEdgeModuleObject -- ^ 'edgeModuleResourceObjectMeta' 
  -> EdgeModuleResourceObject
mkEdgeModuleResourceObject edgeModuleResourceObjectResourcename edgeModuleResourceObjectModulename edgeModuleResourceObjectModuleid edgeModuleResourceObjectMeta =
  EdgeModuleResourceObject
  { edgeModuleResourceObjectResourcename
  , edgeModuleResourceObjectModulename
  , edgeModuleResourceObjectModuleid
  , edgeModuleResourceObjectMeta
  }

-- ** EdgeModuleResourceUpdateObject
-- | EdgeModuleResourceUpdateObject
data EdgeModuleResourceUpdateObject = EdgeModuleResourceUpdateObject
  { edgeModuleResourceUpdateObjectResourcename :: !(Maybe Text) -- ^ "resourcename"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EdgeModuleResourceUpdateObject
instance A.FromJSON EdgeModuleResourceUpdateObject where
  parseJSON = A.withObject "EdgeModuleResourceUpdateObject" $ \o ->
    EdgeModuleResourceUpdateObject
      <$> (o .:? "resourcename")

-- | ToJSON EdgeModuleResourceUpdateObject
instance A.ToJSON EdgeModuleResourceUpdateObject where
  toJSON EdgeModuleResourceUpdateObject {..} =
   _omitNulls
      [ "resourcename" .= edgeModuleResourceUpdateObjectResourcename
      ]


-- | Construct a value of type 'EdgeModuleResourceUpdateObject' (by applying it's required fields, if any)
mkEdgeModuleResourceUpdateObject
  :: EdgeModuleResourceUpdateObject
mkEdgeModuleResourceUpdateObject =
  EdgeModuleResourceUpdateObject
  { edgeModuleResourceUpdateObjectResourcename = Nothing
  }

-- ** EdgeModuleResourceUpdatedObject
-- | EdgeModuleResourceUpdatedObject
data EdgeModuleResourceUpdatedObject = EdgeModuleResourceUpdatedObject
  { edgeModuleResourceUpdatedObjectUpdated :: !(Text) -- ^ /Required/ "updated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EdgeModuleResourceUpdatedObject
instance A.FromJSON EdgeModuleResourceUpdatedObject where
  parseJSON = A.withObject "EdgeModuleResourceUpdatedObject" $ \o ->
    EdgeModuleResourceUpdatedObject
      <$> (o .:  "updated")

-- | ToJSON EdgeModuleResourceUpdatedObject
instance A.ToJSON EdgeModuleResourceUpdatedObject where
  toJSON EdgeModuleResourceUpdatedObject {..} =
   _omitNulls
      [ "updated" .= edgeModuleResourceUpdatedObjectUpdated
      ]


-- | Construct a value of type 'EdgeModuleResourceUpdatedObject' (by applying it's required fields, if any)
mkEdgeModuleResourceUpdatedObject
  :: Text -- ^ 'edgeModuleResourceUpdatedObjectUpdated' 
  -> EdgeModuleResourceUpdatedObject
mkEdgeModuleResourceUpdatedObject edgeModuleResourceUpdatedObjectUpdated =
  EdgeModuleResourceUpdatedObject
  { edgeModuleResourceUpdatedObjectUpdated
  }

-- ** EdgeModuleUpdateObject
-- | EdgeModuleUpdateObject
data EdgeModuleUpdateObject = EdgeModuleUpdateObject
  { edgeModuleUpdateObjectModulename :: !(Text) -- ^ /Required/ "modulename"
  , edgeModuleUpdateObjectProtocol :: !(Text) -- ^ /Required/ "protocol"
  , edgeModuleUpdateObjectProtocolprops :: !(Text) -- ^ /Required/ "protocolprops"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EdgeModuleUpdateObject
instance A.FromJSON EdgeModuleUpdateObject where
  parseJSON = A.withObject "EdgeModuleUpdateObject" $ \o ->
    EdgeModuleUpdateObject
      <$> (o .:  "modulename")
      <*> (o .:  "protocol")
      <*> (o .:  "protocolprops")

-- | ToJSON EdgeModuleUpdateObject
instance A.ToJSON EdgeModuleUpdateObject where
  toJSON EdgeModuleUpdateObject {..} =
   _omitNulls
      [ "modulename" .= edgeModuleUpdateObjectModulename
      , "protocol" .= edgeModuleUpdateObjectProtocol
      , "protocolprops" .= edgeModuleUpdateObjectProtocolprops
      ]


-- | Construct a value of type 'EdgeModuleUpdateObject' (by applying it's required fields, if any)
mkEdgeModuleUpdateObject
  :: Text -- ^ 'edgeModuleUpdateObjectModulename' 
  -> Text -- ^ 'edgeModuleUpdateObjectProtocol' 
  -> Text -- ^ 'edgeModuleUpdateObjectProtocolprops' 
  -> EdgeModuleUpdateObject
mkEdgeModuleUpdateObject edgeModuleUpdateObjectModulename edgeModuleUpdateObjectProtocol edgeModuleUpdateObjectProtocolprops =
  EdgeModuleUpdateObject
  { edgeModuleUpdateObjectModulename
  , edgeModuleUpdateObjectProtocol
  , edgeModuleUpdateObjectProtocolprops
  }

-- ** EdgeModuleUpdatedObject
-- | EdgeModuleUpdatedObject
data EdgeModuleUpdatedObject = EdgeModuleUpdatedObject
  { edgeModuleUpdatedObjectUpdated :: !(Text) -- ^ /Required/ "updated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EdgeModuleUpdatedObject
instance A.FromJSON EdgeModuleUpdatedObject where
  parseJSON = A.withObject "EdgeModuleUpdatedObject" $ \o ->
    EdgeModuleUpdatedObject
      <$> (o .:  "updated")

-- | ToJSON EdgeModuleUpdatedObject
instance A.ToJSON EdgeModuleUpdatedObject where
  toJSON EdgeModuleUpdatedObject {..} =
   _omitNulls
      [ "updated" .= edgeModuleUpdatedObjectUpdated
      ]


-- | Construct a value of type 'EdgeModuleUpdatedObject' (by applying it's required fields, if any)
mkEdgeModuleUpdatedObject
  :: Text -- ^ 'edgeModuleUpdatedObjectUpdated' 
  -> EdgeModuleUpdatedObject
mkEdgeModuleUpdatedObject edgeModuleUpdatedObjectUpdated =
  EdgeModuleUpdatedObject
  { edgeModuleUpdatedObjectUpdated
  }

-- ** FieldGroupObject
-- | FieldGroupObject
data FieldGroupObject = FieldGroupObject
  { fieldGroupObjectName :: !(Text) -- ^ /Required/ "name"
  , fieldGroupObjectFields :: !(Maybe [FieldObjectFields]) -- ^ "fields"
  , fieldGroupObjectCustom :: !(Maybe Bool) -- ^ "custom"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FieldGroupObject
instance A.FromJSON FieldGroupObject where
  parseJSON = A.withObject "FieldGroupObject" $ \o ->
    FieldGroupObject
      <$> (o .:  "name")
      <*> (o .:? "fields")
      <*> (o .:? "custom")

-- | ToJSON FieldGroupObject
instance A.ToJSON FieldGroupObject where
  toJSON FieldGroupObject {..} =
   _omitNulls
      [ "name" .= fieldGroupObjectName
      , "fields" .= fieldGroupObjectFields
      , "custom" .= fieldGroupObjectCustom
      ]


-- | Construct a value of type 'FieldGroupObject' (by applying it's required fields, if any)
mkFieldGroupObject
  :: Text -- ^ 'fieldGroupObjectName' 
  -> FieldGroupObject
mkFieldGroupObject fieldGroupObjectName =
  FieldGroupObject
  { fieldGroupObjectName
  , fieldGroupObjectFields = Nothing
  , fieldGroupObjectCustom = Nothing
  }

-- ** FieldInstallationObject
-- | FieldInstallationObject
data FieldInstallationObject = FieldInstallationObject
  { fieldInstallationObjectName :: !(Text) -- ^ /Required/ "name"
  , fieldInstallationObjectFields :: !(Maybe [FieldObjectFields]) -- ^ "fields"
  , fieldInstallationObjectCustom :: !(Maybe Bool) -- ^ "custom"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FieldInstallationObject
instance A.FromJSON FieldInstallationObject where
  parseJSON = A.withObject "FieldInstallationObject" $ \o ->
    FieldInstallationObject
      <$> (o .:  "name")
      <*> (o .:? "fields")
      <*> (o .:? "custom")

-- | ToJSON FieldInstallationObject
instance A.ToJSON FieldInstallationObject where
  toJSON FieldInstallationObject {..} =
   _omitNulls
      [ "name" .= fieldInstallationObjectName
      , "fields" .= fieldInstallationObjectFields
      , "custom" .= fieldInstallationObjectCustom
      ]


-- | Construct a value of type 'FieldInstallationObject' (by applying it's required fields, if any)
mkFieldInstallationObject
  :: Text -- ^ 'fieldInstallationObjectName' 
  -> FieldInstallationObject
mkFieldInstallationObject fieldInstallationObjectName =
  FieldInstallationObject
  { fieldInstallationObjectName
  , fieldInstallationObjectFields = Nothing
  , fieldInstallationObjectCustom = Nothing
  }

-- ** FieldObject
-- | FieldObject
data FieldObject = FieldObject
  { fieldObjectName :: !(Text) -- ^ /Required/ "name"
  , fieldObjectFields :: !(Maybe [FieldObjectFields]) -- ^ "fields"
  , fieldObjectCustom :: !(Maybe Bool) -- ^ "custom"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FieldObject
instance A.FromJSON FieldObject where
  parseJSON = A.withObject "FieldObject" $ \o ->
    FieldObject
      <$> (o .:  "name")
      <*> (o .:? "fields")
      <*> (o .:? "custom")

-- | ToJSON FieldObject
instance A.ToJSON FieldObject where
  toJSON FieldObject {..} =
   _omitNulls
      [ "name" .= fieldObjectName
      , "fields" .= fieldObjectFields
      , "custom" .= fieldObjectCustom
      ]


-- | Construct a value of type 'FieldObject' (by applying it's required fields, if any)
mkFieldObject
  :: Text -- ^ 'fieldObjectName' 
  -> FieldObject
mkFieldObject fieldObjectName =
  FieldObject
  { fieldObjectName
  , fieldObjectFields = Nothing
  , fieldObjectCustom = Nothing
  }

-- ** FieldObjectFields
-- | FieldObjectFields
data FieldObjectFields = FieldObjectFields
  { fieldObjectFieldsName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FieldObjectFields
instance A.FromJSON FieldObjectFields where
  parseJSON = A.withObject "FieldObjectFields" $ \o ->
    FieldObjectFields
      <$> (o .:? "name")

-- | ToJSON FieldObjectFields
instance A.ToJSON FieldObjectFields where
  toJSON FieldObjectFields {..} =
   _omitNulls
      [ "name" .= fieldObjectFieldsName
      ]


-- | Construct a value of type 'FieldObjectFields' (by applying it's required fields, if any)
mkFieldObjectFields
  :: FieldObjectFields
mkFieldObjectFields =
  FieldObjectFields
  { fieldObjectFieldsName = Nothing
  }

-- ** FieldsEdgeModuleObject
-- | FieldsEdgeModuleObject
data FieldsEdgeModuleObject = FieldsEdgeModuleObject
  { fieldsEdgeModuleObjectName :: !(Text) -- ^ /Required/ "name"
  , fieldsEdgeModuleObjectFields :: !(Maybe [FieldObjectFields]) -- ^ "fields"
  , fieldsEdgeModuleObjectCustom :: !(Maybe Bool) -- ^ "custom"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FieldsEdgeModuleObject
instance A.FromJSON FieldsEdgeModuleObject where
  parseJSON = A.withObject "FieldsEdgeModuleObject" $ \o ->
    FieldsEdgeModuleObject
      <$> (o .:  "name")
      <*> (o .:? "fields")
      <*> (o .:? "custom")

-- | ToJSON FieldsEdgeModuleObject
instance A.ToJSON FieldsEdgeModuleObject where
  toJSON FieldsEdgeModuleObject {..} =
   _omitNulls
      [ "name" .= fieldsEdgeModuleObjectName
      , "fields" .= fieldsEdgeModuleObjectFields
      , "custom" .= fieldsEdgeModuleObjectCustom
      ]


-- | Construct a value of type 'FieldsEdgeModuleObject' (by applying it's required fields, if any)
mkFieldsEdgeModuleObject
  :: Text -- ^ 'fieldsEdgeModuleObjectName' 
  -> FieldsEdgeModuleObject
mkFieldsEdgeModuleObject fieldsEdgeModuleObjectName =
  FieldsEdgeModuleObject
  { fieldsEdgeModuleObjectName
  , fieldsEdgeModuleObjectFields = Nothing
  , fieldsEdgeModuleObjectCustom = Nothing
  }

-- ** GroupAddObject
-- | GroupAddObject
data GroupAddObject = GroupAddObject
  { groupAddObjectGroupname :: !(Text) -- ^ /Required/ "groupname"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupAddObject
instance A.FromJSON GroupAddObject where
  parseJSON = A.withObject "GroupAddObject" $ \o ->
    GroupAddObject
      <$> (o .:  "groupname")

-- | ToJSON GroupAddObject
instance A.ToJSON GroupAddObject where
  toJSON GroupAddObject {..} =
   _omitNulls
      [ "groupname" .= groupAddObjectGroupname
      ]


-- | Construct a value of type 'GroupAddObject' (by applying it's required fields, if any)
mkGroupAddObject
  :: Text -- ^ 'groupAddObjectGroupname' 
  -> GroupAddObject
mkGroupAddObject groupAddObjectGroupname =
  GroupAddObject
  { groupAddObjectGroupname
  }

-- ** GroupName
-- | GroupName
newtype GroupName = GroupName
  { unGroupName :: Text
  } deriving (P.Eq, P.Show, P.Typeable, A.ToJSON, A.FromJSON, WH.ToHttpApiData, WH.FromHttpApiData)


-- ** GroupObject
-- | GroupObject
data GroupObject = GroupObject
  { groupObjectName :: !(Text) -- ^ /Required/ "name"
  , groupObjectMeta :: !(MetaGroupObject) -- ^ /Required/ "_meta"
  , groupObjectUsers :: !(Maybe [Text]) -- ^ "users"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupObject
instance A.FromJSON GroupObject where
  parseJSON = A.withObject "GroupObject" $ \o ->
    GroupObject
      <$> (o .:  "name")
      <*> (o .:  "_meta")
      <*> (o .:? "users")

-- | ToJSON GroupObject
instance A.ToJSON GroupObject where
  toJSON GroupObject {..} =
   _omitNulls
      [ "name" .= groupObjectName
      , "_meta" .= groupObjectMeta
      , "users" .= groupObjectUsers
      ]


-- | Construct a value of type 'GroupObject' (by applying it's required fields, if any)
mkGroupObject
  :: Text -- ^ 'groupObjectName' 
  -> MetaGroupObject -- ^ 'groupObjectMeta' 
  -> GroupObject
mkGroupObject groupObjectName groupObjectMeta =
  GroupObject
  { groupObjectName
  , groupObjectMeta
  , groupObjectUsers = Nothing
  }

-- ** InstallationAddObject
-- | InstallationAddObject
data InstallationAddObject = InstallationAddObject
  { installationAddObjectDeviceToken :: !(Text) -- ^ /Required/ "deviceToken"
  , installationAddObjectDeviceType :: !(Text) -- ^ /Required/ "deviceType"
  , installationAddObjectChannels :: !(Maybe [Text]) -- ^ "channels"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstallationAddObject
instance A.FromJSON InstallationAddObject where
  parseJSON = A.withObject "InstallationAddObject" $ \o ->
    InstallationAddObject
      <$> (o .:  "deviceToken")
      <*> (o .:  "deviceType")
      <*> (o .:? "channels")

-- | ToJSON InstallationAddObject
instance A.ToJSON InstallationAddObject where
  toJSON InstallationAddObject {..} =
   _omitNulls
      [ "deviceToken" .= installationAddObjectDeviceToken
      , "deviceType" .= installationAddObjectDeviceType
      , "channels" .= installationAddObjectChannels
      ]


-- | Construct a value of type 'InstallationAddObject' (by applying it's required fields, if any)
mkInstallationAddObject
  :: Text -- ^ 'installationAddObjectDeviceToken' 
  -> Text -- ^ 'installationAddObjectDeviceType' 
  -> InstallationAddObject
mkInstallationAddObject installationAddObjectDeviceToken installationAddObjectDeviceType =
  InstallationAddObject
  { installationAddObjectDeviceToken
  , installationAddObjectDeviceType
  , installationAddObjectChannels = Nothing
  }

-- ** InstallationAddedObject
-- | InstallationAddedObject
data InstallationAddedObject = InstallationAddedObject
  { installationAddedObjectId :: !(Text) -- ^ /Required/ "_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstallationAddedObject
instance A.FromJSON InstallationAddedObject where
  parseJSON = A.withObject "InstallationAddedObject" $ \o ->
    InstallationAddedObject
      <$> (o .:  "_id")

-- | ToJSON InstallationAddedObject
instance A.ToJSON InstallationAddedObject where
  toJSON InstallationAddedObject {..} =
   _omitNulls
      [ "_id" .= installationAddedObjectId
      ]


-- | Construct a value of type 'InstallationAddedObject' (by applying it's required fields, if any)
mkInstallationAddedObject
  :: Text -- ^ 'installationAddedObjectId' 
  -> InstallationAddedObject
mkInstallationAddedObject installationAddedObjectId =
  InstallationAddedObject
  { installationAddedObjectId
  }

-- ** InstallationObject
-- | InstallationObject
data InstallationObject = InstallationObject
  { installationObjectId :: !(Text) -- ^ /Required/ "_id"
  , installationObjectDeviceToken :: !(Text) -- ^ /Required/ "deviceToken"
  , installationObjectDeviceType :: !(E'DeviceType) -- ^ /Required/ "deviceType"
  , installationObjectMeta :: !(MetaInstallationObject) -- ^ /Required/ "_meta"
  , installationObjectChannels :: !(Maybe [Text]) -- ^ "channels"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InstallationObject
instance A.FromJSON InstallationObject where
  parseJSON = A.withObject "InstallationObject" $ \o ->
    InstallationObject
      <$> (o .:  "_id")
      <*> (o .:  "deviceToken")
      <*> (o .:  "deviceType")
      <*> (o .:  "_meta")
      <*> (o .:? "channels")

-- | ToJSON InstallationObject
instance A.ToJSON InstallationObject where
  toJSON InstallationObject {..} =
   _omitNulls
      [ "_id" .= installationObjectId
      , "deviceToken" .= installationObjectDeviceToken
      , "deviceType" .= installationObjectDeviceType
      , "_meta" .= installationObjectMeta
      , "channels" .= installationObjectChannels
      ]


-- | Construct a value of type 'InstallationObject' (by applying it's required fields, if any)
mkInstallationObject
  :: Text -- ^ 'installationObjectId' 
  -> Text -- ^ 'installationObjectDeviceToken' 
  -> E'DeviceType -- ^ 'installationObjectDeviceType' 
  -> MetaInstallationObject -- ^ 'installationObjectMeta' 
  -> InstallationObject
mkInstallationObject installationObjectId installationObjectDeviceToken installationObjectDeviceType installationObjectMeta =
  InstallationObject
  { installationObjectId
  , installationObjectDeviceToken
  , installationObjectDeviceType
  , installationObjectMeta
  , installationObjectChannels = Nothing
  }

-- ** MetaEdgeModuleObject
-- | MetaEdgeModuleObject
data MetaEdgeModuleObject = MetaEdgeModuleObject
  { metaEdgeModuleObjectCreator :: !(Text) -- ^ /Required/ "creator"
  , metaEdgeModuleObjectCreated :: !(Text) -- ^ /Required/ "created"
  , metaEdgeModuleObjectUpdated :: !(Maybe Text) -- ^ "updated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MetaEdgeModuleObject
instance A.FromJSON MetaEdgeModuleObject where
  parseJSON = A.withObject "MetaEdgeModuleObject" $ \o ->
    MetaEdgeModuleObject
      <$> (o .:  "creator")
      <*> (o .:  "created")
      <*> (o .:? "updated")

-- | ToJSON MetaEdgeModuleObject
instance A.ToJSON MetaEdgeModuleObject where
  toJSON MetaEdgeModuleObject {..} =
   _omitNulls
      [ "creator" .= metaEdgeModuleObjectCreator
      , "created" .= metaEdgeModuleObjectCreated
      , "updated" .= metaEdgeModuleObjectUpdated
      ]


-- | Construct a value of type 'MetaEdgeModuleObject' (by applying it's required fields, if any)
mkMetaEdgeModuleObject
  :: Text -- ^ 'metaEdgeModuleObjectCreator' 
  -> Text -- ^ 'metaEdgeModuleObjectCreated' 
  -> MetaEdgeModuleObject
mkMetaEdgeModuleObject metaEdgeModuleObjectCreator metaEdgeModuleObjectCreated =
  MetaEdgeModuleObject
  { metaEdgeModuleObjectCreator
  , metaEdgeModuleObjectCreated
  , metaEdgeModuleObjectUpdated = Nothing
  }

-- ** MetaGroupObject
-- | MetaGroupObject
data MetaGroupObject = MetaGroupObject
  { metaGroupObjectCreator :: !(Text) -- ^ /Required/ "creator"
  , metaGroupObjectCreated :: !(Text) -- ^ /Required/ "created"
  , metaGroupObjectUpdated :: !(Maybe Text) -- ^ "updated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MetaGroupObject
instance A.FromJSON MetaGroupObject where
  parseJSON = A.withObject "MetaGroupObject" $ \o ->
    MetaGroupObject
      <$> (o .:  "creator")
      <*> (o .:  "created")
      <*> (o .:? "updated")

-- | ToJSON MetaGroupObject
instance A.ToJSON MetaGroupObject where
  toJSON MetaGroupObject {..} =
   _omitNulls
      [ "creator" .= metaGroupObjectCreator
      , "created" .= metaGroupObjectCreated
      , "updated" .= metaGroupObjectUpdated
      ]


-- | Construct a value of type 'MetaGroupObject' (by applying it's required fields, if any)
mkMetaGroupObject
  :: Text -- ^ 'metaGroupObjectCreator' 
  -> Text -- ^ 'metaGroupObjectCreated' 
  -> MetaGroupObject
mkMetaGroupObject metaGroupObjectCreator metaGroupObjectCreated =
  MetaGroupObject
  { metaGroupObjectCreator
  , metaGroupObjectCreated
  , metaGroupObjectUpdated = Nothing
  }

-- ** MetaInstallationObject
-- | MetaInstallationObject
data MetaInstallationObject = MetaInstallationObject
  { metaInstallationObjectCreator :: !(Text) -- ^ /Required/ "creator"
  , metaInstallationObjectCreated :: !(Text) -- ^ /Required/ "created"
  , metaInstallationObjectUpdated :: !(Maybe Text) -- ^ "updated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MetaInstallationObject
instance A.FromJSON MetaInstallationObject where
  parseJSON = A.withObject "MetaInstallationObject" $ \o ->
    MetaInstallationObject
      <$> (o .:  "creator")
      <*> (o .:  "created")
      <*> (o .:? "updated")

-- | ToJSON MetaInstallationObject
instance A.ToJSON MetaInstallationObject where
  toJSON MetaInstallationObject {..} =
   _omitNulls
      [ "creator" .= metaInstallationObjectCreator
      , "created" .= metaInstallationObjectCreated
      , "updated" .= metaInstallationObjectUpdated
      ]


-- | Construct a value of type 'MetaInstallationObject' (by applying it's required fields, if any)
mkMetaInstallationObject
  :: Text -- ^ 'metaInstallationObjectCreator' 
  -> Text -- ^ 'metaInstallationObjectCreated' 
  -> MetaInstallationObject
mkMetaInstallationObject metaInstallationObjectCreator metaInstallationObjectCreated =
  MetaInstallationObject
  { metaInstallationObjectCreator
  , metaInstallationObjectCreated
  , metaInstallationObjectUpdated = Nothing
  }

-- ** MetaObject
-- | MetaObject
data MetaObject = MetaObject
  { metaObjectCreator :: !(Text) -- ^ /Required/ "creator"
  , metaObjectCreated :: !(Text) -- ^ /Required/ "created"
  , metaObjectUpdated :: !(Maybe Text) -- ^ "updated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MetaObject
instance A.FromJSON MetaObject where
  parseJSON = A.withObject "MetaObject" $ \o ->
    MetaObject
      <$> (o .:  "creator")
      <*> (o .:  "created")
      <*> (o .:? "updated")

-- | ToJSON MetaObject
instance A.ToJSON MetaObject where
  toJSON MetaObject {..} =
   _omitNulls
      [ "creator" .= metaObjectCreator
      , "created" .= metaObjectCreated
      , "updated" .= metaObjectUpdated
      ]


-- | Construct a value of type 'MetaObject' (by applying it's required fields, if any)
mkMetaObject
  :: Text -- ^ 'metaObjectCreator' 
  -> Text -- ^ 'metaObjectCreated' 
  -> MetaObject
mkMetaObject metaObjectCreator metaObjectCreated =
  MetaObject
  { metaObjectCreator
  , metaObjectCreated
  , metaObjectUpdated = Nothing
  }

-- ** PushDataObject
-- | PushDataObject
data PushDataObject = PushDataObject
  { pushDataObjectGcm :: !(Maybe PushDataObjectGcm) -- ^ "gcm"
  , pushDataObjectAps :: !(Maybe PushDataObjectAps) -- ^ "aps"
  , pushDataObjectExtras :: !(Maybe PushDataObjectExtras) -- ^ "extras"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushDataObject
instance A.FromJSON PushDataObject where
  parseJSON = A.withObject "PushDataObject" $ \o ->
    PushDataObject
      <$> (o .:? "gcm")
      <*> (o .:? "aps")
      <*> (o .:? "extras")

-- | ToJSON PushDataObject
instance A.ToJSON PushDataObject where
  toJSON PushDataObject {..} =
   _omitNulls
      [ "gcm" .= pushDataObjectGcm
      , "aps" .= pushDataObjectAps
      , "extras" .= pushDataObjectExtras
      ]


-- | Construct a value of type 'PushDataObject' (by applying it's required fields, if any)
mkPushDataObject
  :: PushDataObject
mkPushDataObject =
  PushDataObject
  { pushDataObjectGcm = Nothing
  , pushDataObjectAps = Nothing
  , pushDataObjectExtras = Nothing
  }

-- ** PushDataObjectAps
-- | PushDataObjectAps
data PushDataObjectAps = PushDataObjectAps
  { pushDataObjectApsAlert :: !(Maybe Text) -- ^ "alert"
  , pushDataObjectApsBadge :: !(Maybe Text) -- ^ "badge"
  , pushDataObjectApsSound :: !(Maybe Text) -- ^ "sound"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushDataObjectAps
instance A.FromJSON PushDataObjectAps where
  parseJSON = A.withObject "PushDataObjectAps" $ \o ->
    PushDataObjectAps
      <$> (o .:? "alert")
      <*> (o .:? "badge")
      <*> (o .:? "sound")

-- | ToJSON PushDataObjectAps
instance A.ToJSON PushDataObjectAps where
  toJSON PushDataObjectAps {..} =
   _omitNulls
      [ "alert" .= pushDataObjectApsAlert
      , "badge" .= pushDataObjectApsBadge
      , "sound" .= pushDataObjectApsSound
      ]


-- | Construct a value of type 'PushDataObjectAps' (by applying it's required fields, if any)
mkPushDataObjectAps
  :: PushDataObjectAps
mkPushDataObjectAps =
  PushDataObjectAps
  { pushDataObjectApsAlert = Nothing
  , pushDataObjectApsBadge = Nothing
  , pushDataObjectApsSound = Nothing
  }

-- ** PushDataObjectExtras
-- | PushDataObjectExtras
data PushDataObjectExtras = PushDataObjectExtras
  { pushDataObjectExtrasMessage :: !(Maybe Text) -- ^ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushDataObjectExtras
instance A.FromJSON PushDataObjectExtras where
  parseJSON = A.withObject "PushDataObjectExtras" $ \o ->
    PushDataObjectExtras
      <$> (o .:? "message")

-- | ToJSON PushDataObjectExtras
instance A.ToJSON PushDataObjectExtras where
  toJSON PushDataObjectExtras {..} =
   _omitNulls
      [ "message" .= pushDataObjectExtrasMessage
      ]


-- | Construct a value of type 'PushDataObjectExtras' (by applying it's required fields, if any)
mkPushDataObjectExtras
  :: PushDataObjectExtras
mkPushDataObjectExtras =
  PushDataObjectExtras
  { pushDataObjectExtrasMessage = Nothing
  }

-- ** PushDataObjectGcm
-- | PushDataObjectGcm
data PushDataObjectGcm = PushDataObjectGcm
  { pushDataObjectGcmMessage :: !(Maybe Text) -- ^ "message"
  , pushDataObjectGcmTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushDataObjectGcm
instance A.FromJSON PushDataObjectGcm where
  parseJSON = A.withObject "PushDataObjectGcm" $ \o ->
    PushDataObjectGcm
      <$> (o .:? "message")
      <*> (o .:? "title")

-- | ToJSON PushDataObjectGcm
instance A.ToJSON PushDataObjectGcm where
  toJSON PushDataObjectGcm {..} =
   _omitNulls
      [ "message" .= pushDataObjectGcmMessage
      , "title" .= pushDataObjectGcmTitle
      ]


-- | Construct a value of type 'PushDataObjectGcm' (by applying it's required fields, if any)
mkPushDataObjectGcm
  :: PushDataObjectGcm
mkPushDataObjectGcm =
  PushDataObjectGcm
  { pushDataObjectGcmMessage = Nothing
  , pushDataObjectGcmTitle = Nothing
  }

-- ** PushObject
-- | PushObject
data PushObject = PushObject
  { pushObjectData :: !(PushDataObject) -- ^ /Required/ "data"
  , pushObjectChannels :: !(Maybe [Text]) -- ^ "channels"
  , pushObjectWhere :: !(PushWhereObject) -- ^ /Required/ "where"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushObject
instance A.FromJSON PushObject where
  parseJSON = A.withObject "PushObject" $ \o ->
    PushObject
      <$> (o .:  "data")
      <*> (o .:? "channels")
      <*> (o .:  "where")

-- | ToJSON PushObject
instance A.ToJSON PushObject where
  toJSON PushObject {..} =
   _omitNulls
      [ "data" .= pushObjectData
      , "channels" .= pushObjectChannels
      , "where" .= pushObjectWhere
      ]


-- | Construct a value of type 'PushObject' (by applying it's required fields, if any)
mkPushObject
  :: PushDataObject -- ^ 'pushObjectData' 
  -> PushWhereObject -- ^ 'pushObjectWhere' 
  -> PushObject
mkPushObject pushObjectData pushObjectWhere =
  PushObject
  { pushObjectData
  , pushObjectChannels = Nothing
  , pushObjectWhere
  }

-- ** PushWhereObject
-- | PushWhereObject
data PushWhereObject = PushWhereObject
  { pushWhereObjectDeviceType :: !(Maybe E'DeviceType) -- ^ "deviceType"
  , pushWhereObjectDeviceToken :: !(Maybe PushWhereObjectDeviceToken) -- ^ "deviceToken"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushWhereObject
instance A.FromJSON PushWhereObject where
  parseJSON = A.withObject "PushWhereObject" $ \o ->
    PushWhereObject
      <$> (o .:? "deviceType")
      <*> (o .:? "deviceToken")

-- | ToJSON PushWhereObject
instance A.ToJSON PushWhereObject where
  toJSON PushWhereObject {..} =
   _omitNulls
      [ "deviceType" .= pushWhereObjectDeviceType
      , "deviceToken" .= pushWhereObjectDeviceToken
      ]


-- | Construct a value of type 'PushWhereObject' (by applying it's required fields, if any)
mkPushWhereObject
  :: PushWhereObject
mkPushWhereObject =
  PushWhereObject
  { pushWhereObjectDeviceType = Nothing
  , pushWhereObjectDeviceToken = Nothing
  }

-- ** PushWhereObjectDeviceToken
-- | PushWhereObjectDeviceToken
-- $in
data PushWhereObjectDeviceToken = PushWhereObjectDeviceToken
  { pushWhereObjectDeviceTokenIn :: !([Text]) -- ^ /Required/ "$in"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushWhereObjectDeviceToken
instance A.FromJSON PushWhereObjectDeviceToken where
  parseJSON = A.withObject "PushWhereObjectDeviceToken" $ \o ->
    PushWhereObjectDeviceToken
      <$> (o .:  "$in")

-- | ToJSON PushWhereObjectDeviceToken
instance A.ToJSON PushWhereObjectDeviceToken where
  toJSON PushWhereObjectDeviceToken {..} =
   _omitNulls
      [ "$in" .= pushWhereObjectDeviceTokenIn
      ]


-- | Construct a value of type 'PushWhereObjectDeviceToken' (by applying it's required fields, if any)
mkPushWhereObjectDeviceToken
  :: [Text] -- ^ 'pushWhereObjectDeviceTokenIn' 
  -> PushWhereObjectDeviceToken
mkPushWhereObjectDeviceToken pushWhereObjectDeviceTokenIn =
  PushWhereObjectDeviceToken
  { pushWhereObjectDeviceTokenIn
  }

-- ** UpdateGroupObject
-- | UpdateGroupObject
data UpdateGroupObject = UpdateGroupObject
  { updateGroupObjectFieldName :: !(Maybe Text) -- ^ "fieldName"
  , updateGroupObjectUsers :: !(Maybe [Text]) -- ^ "users"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateGroupObject
instance A.FromJSON UpdateGroupObject where
  parseJSON = A.withObject "UpdateGroupObject" $ \o ->
    UpdateGroupObject
      <$> (o .:? "fieldName")
      <*> (o .:? "users")

-- | ToJSON UpdateGroupObject
instance A.ToJSON UpdateGroupObject where
  toJSON UpdateGroupObject {..} =
   _omitNulls
      [ "fieldName" .= updateGroupObjectFieldName
      , "users" .= updateGroupObjectUsers
      ]


-- | Construct a value of type 'UpdateGroupObject' (by applying it's required fields, if any)
mkUpdateGroupObject
  :: UpdateGroupObject
mkUpdateGroupObject =
  UpdateGroupObject
  { updateGroupObjectFieldName = Nothing
  , updateGroupObjectUsers = Nothing
  }

-- ** UpdateInstallationObject
-- | UpdateInstallationObject
data UpdateInstallationObject = UpdateInstallationObject
  { updateInstallationObjectChannels :: !(Maybe [Text]) -- ^ "channels"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateInstallationObject
instance A.FromJSON UpdateInstallationObject where
  parseJSON = A.withObject "UpdateInstallationObject" $ \o ->
    UpdateInstallationObject
      <$> (o .:? "channels")

-- | ToJSON UpdateInstallationObject
instance A.ToJSON UpdateInstallationObject where
  toJSON UpdateInstallationObject {..} =
   _omitNulls
      [ "channels" .= updateInstallationObjectChannels
      ]


-- | Construct a value of type 'UpdateInstallationObject' (by applying it's required fields, if any)
mkUpdateInstallationObject
  :: UpdateInstallationObject
mkUpdateInstallationObject =
  UpdateInstallationObject
  { updateInstallationObjectChannels = Nothing
  }

-- ** UpdateObject
-- | UpdateObject
data UpdateObject = UpdateObject
  { updateObjectFieldName :: !(Maybe Text) -- ^ "fieldName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateObject
instance A.FromJSON UpdateObject where
  parseJSON = A.withObject "UpdateObject" $ \o ->
    UpdateObject
      <$> (o .:? "fieldName")

-- | ToJSON UpdateObject
instance A.ToJSON UpdateObject where
  toJSON UpdateObject {..} =
   _omitNulls
      [ "fieldName" .= updateObjectFieldName
      ]


-- | Construct a value of type 'UpdateObject' (by applying it's required fields, if any)
mkUpdateObject
  :: UpdateObject
mkUpdateObject =
  UpdateObject
  { updateObjectFieldName = Nothing
  }

-- ** UpdatedGroupObject
-- | UpdatedGroupObject
data UpdatedGroupObject = UpdatedGroupObject
  { updatedGroupObjectUpdated :: !(Text) -- ^ /Required/ "updated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdatedGroupObject
instance A.FromJSON UpdatedGroupObject where
  parseJSON = A.withObject "UpdatedGroupObject" $ \o ->
    UpdatedGroupObject
      <$> (o .:  "updated")

-- | ToJSON UpdatedGroupObject
instance A.ToJSON UpdatedGroupObject where
  toJSON UpdatedGroupObject {..} =
   _omitNulls
      [ "updated" .= updatedGroupObjectUpdated
      ]


-- | Construct a value of type 'UpdatedGroupObject' (by applying it's required fields, if any)
mkUpdatedGroupObject
  :: Text -- ^ 'updatedGroupObjectUpdated' 
  -> UpdatedGroupObject
mkUpdatedGroupObject updatedGroupObjectUpdated =
  UpdatedGroupObject
  { updatedGroupObjectUpdated
  }

-- ** UpdatedInstallationObject
-- | UpdatedInstallationObject
data UpdatedInstallationObject = UpdatedInstallationObject
  { updatedInstallationObjectUpdated :: !(Text) -- ^ /Required/ "updated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdatedInstallationObject
instance A.FromJSON UpdatedInstallationObject where
  parseJSON = A.withObject "UpdatedInstallationObject" $ \o ->
    UpdatedInstallationObject
      <$> (o .:  "updated")

-- | ToJSON UpdatedInstallationObject
instance A.ToJSON UpdatedInstallationObject where
  toJSON UpdatedInstallationObject {..} =
   _omitNulls
      [ "updated" .= updatedInstallationObjectUpdated
      ]


-- | Construct a value of type 'UpdatedInstallationObject' (by applying it's required fields, if any)
mkUpdatedInstallationObject
  :: Text -- ^ 'updatedInstallationObjectUpdated' 
  -> UpdatedInstallationObject
mkUpdatedInstallationObject updatedInstallationObjectUpdated =
  UpdatedInstallationObject
  { updatedInstallationObjectUpdated
  }

-- ** UpdatedObject
-- | UpdatedObject
data UpdatedObject = UpdatedObject
  { updatedObjectUpdated :: !(Text) -- ^ /Required/ "updated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdatedObject
instance A.FromJSON UpdatedObject where
  parseJSON = A.withObject "UpdatedObject" $ \o ->
    UpdatedObject
      <$> (o .:  "updated")

-- | ToJSON UpdatedObject
instance A.ToJSON UpdatedObject where
  toJSON UpdatedObject {..} =
   _omitNulls
      [ "updated" .= updatedObjectUpdated
      ]


-- | Construct a value of type 'UpdatedObject' (by applying it's required fields, if any)
mkUpdatedObject
  :: Text -- ^ 'updatedObjectUpdated' 
  -> UpdatedObject
mkUpdatedObject updatedObjectUpdated =
  UpdatedObject
  { updatedObjectUpdated
  }

-- ** UserCredentialsObject
-- | UserCredentialsObject
data UserCredentialsObject = UserCredentialsObject
  { userCredentialsObjectUsername :: !(Text) -- ^ /Required/ "username"
  , userCredentialsObjectPassword :: !(Text) -- ^ /Required/ "password"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserCredentialsObject
instance A.FromJSON UserCredentialsObject where
  parseJSON = A.withObject "UserCredentialsObject" $ \o ->
    UserCredentialsObject
      <$> (o .:  "username")
      <*> (o .:  "password")

-- | ToJSON UserCredentialsObject
instance A.ToJSON UserCredentialsObject where
  toJSON UserCredentialsObject {..} =
   _omitNulls
      [ "username" .= userCredentialsObjectUsername
      , "password" .= userCredentialsObjectPassword
      ]


-- | Construct a value of type 'UserCredentialsObject' (by applying it's required fields, if any)
mkUserCredentialsObject
  :: Text -- ^ 'userCredentialsObjectUsername' 
  -> Text -- ^ 'userCredentialsObjectPassword' 
  -> UserCredentialsObject
mkUserCredentialsObject userCredentialsObjectUsername userCredentialsObjectPassword =
  UserCredentialsObject
  { userCredentialsObjectUsername
  , userCredentialsObjectPassword
  }

-- ** UserObject
-- | UserObject
data UserObject = UserObject
  { userObjectId :: !(Text) -- ^ /Required/ "id"
  , userObjectUsername :: !(Text) -- ^ /Required/ "username"
  , userObjectMeta :: !(MetaObject) -- ^ /Required/ "_meta"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserObject
instance A.FromJSON UserObject where
  parseJSON = A.withObject "UserObject" $ \o ->
    UserObject
      <$> (o .:  "id")
      <*> (o .:  "username")
      <*> (o .:  "_meta")

-- | ToJSON UserObject
instance A.ToJSON UserObject where
  toJSON UserObject {..} =
   _omitNulls
      [ "id" .= userObjectId
      , "username" .= userObjectUsername
      , "_meta" .= userObjectMeta
      ]


-- | Construct a value of type 'UserObject' (by applying it's required fields, if any)
mkUserObject
  :: Text -- ^ 'userObjectId' 
  -> Text -- ^ 'userObjectUsername' 
  -> MetaObject -- ^ 'userObjectMeta' 
  -> UserObject
mkUserObject userObjectId userObjectUsername userObjectMeta =
  UserObject
  { userObjectId
  , userObjectUsername
  , userObjectMeta
  }

-- ** UserSignUpResponseObject
-- | UserSignUpResponseObject
data UserSignUpResponseObject = UserSignUpResponseObject
  { userSignUpResponseObjectId :: !(Text) -- ^ /Required/ "_id"
  , userSignUpResponseObjectSessionToken :: !(Text) -- ^ /Required/ "sessionToken"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSignUpResponseObject
instance A.FromJSON UserSignUpResponseObject where
  parseJSON = A.withObject "UserSignUpResponseObject" $ \o ->
    UserSignUpResponseObject
      <$> (o .:  "_id")
      <*> (o .:  "sessionToken")

-- | ToJSON UserSignUpResponseObject
instance A.ToJSON UserSignUpResponseObject where
  toJSON UserSignUpResponseObject {..} =
   _omitNulls
      [ "_id" .= userSignUpResponseObjectId
      , "sessionToken" .= userSignUpResponseObjectSessionToken
      ]


-- | Construct a value of type 'UserSignUpResponseObject' (by applying it's required fields, if any)
mkUserSignUpResponseObject
  :: Text -- ^ 'userSignUpResponseObjectId' 
  -> Text -- ^ 'userSignUpResponseObjectSessionToken' 
  -> UserSignUpResponseObject
mkUserSignUpResponseObject userSignUpResponseObjectId userSignUpResponseObjectSessionToken =
  UserSignUpResponseObject
  { userSignUpResponseObjectId
  , userSignUpResponseObjectSessionToken
  }

-- ** UserTokenObject
-- | UserTokenObject
data UserTokenObject = UserTokenObject
  { userTokenObjectId :: !(Text) -- ^ /Required/ "id"
  , userTokenObjectUsername :: !(Text) -- ^ /Required/ "username"
  , userTokenObjectMeta :: !(MetaObject) -- ^ /Required/ "_meta"
  , userTokenObjectSessiontoken :: !(Text) -- ^ /Required/ "sessiontoken"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserTokenObject
instance A.FromJSON UserTokenObject where
  parseJSON = A.withObject "UserTokenObject" $ \o ->
    UserTokenObject
      <$> (o .:  "id")
      <*> (o .:  "username")
      <*> (o .:  "_meta")
      <*> (o .:  "sessiontoken")

-- | ToJSON UserTokenObject
instance A.ToJSON UserTokenObject where
  toJSON UserTokenObject {..} =
   _omitNulls
      [ "id" .= userTokenObjectId
      , "username" .= userTokenObjectUsername
      , "_meta" .= userTokenObjectMeta
      , "sessiontoken" .= userTokenObjectSessiontoken
      ]


-- | Construct a value of type 'UserTokenObject' (by applying it's required fields, if any)
mkUserTokenObject
  :: Text -- ^ 'userTokenObjectId' 
  -> Text -- ^ 'userTokenObjectUsername' 
  -> MetaObject -- ^ 'userTokenObjectMeta' 
  -> Text -- ^ 'userTokenObjectSessiontoken' 
  -> UserTokenObject
mkUserTokenObject userTokenObjectId userTokenObjectUsername userTokenObjectMeta userTokenObjectSessiontoken =
  UserTokenObject
  { userTokenObjectId
  , userTokenObjectUsername
  , userTokenObjectMeta
  , userTokenObjectSessiontoken
  }

-- ** UseridObject
-- | UseridObject
data UseridObject = UseridObject
  { useridObjectId :: !(Text) -- ^ /Required/ "_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UseridObject
instance A.FromJSON UseridObject where
  parseJSON = A.withObject "UseridObject" $ \o ->
    UseridObject
      <$> (o .:  "_id")

-- | ToJSON UseridObject
instance A.ToJSON UseridObject where
  toJSON UseridObject {..} =
   _omitNulls
      [ "_id" .= useridObjectId
      ]


-- | Construct a value of type 'UseridObject' (by applying it's required fields, if any)
mkUseridObject
  :: Text -- ^ 'useridObjectId' 
  -> UseridObject
mkUseridObject useridObjectId =
  UseridObject
  { useridObjectId
  }

-- ** VersionObject
-- | VersionObject
data VersionObject = VersionObject
  { versionObjectVersion :: !(Maybe Text) -- ^ "version"
  , versionObjectServer :: !(Maybe Text) -- ^ "server"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VersionObject
instance A.FromJSON VersionObject where
  parseJSON = A.withObject "VersionObject" $ \o ->
    VersionObject
      <$> (o .:? "version")
      <*> (o .:? "server")

-- | ToJSON VersionObject
instance A.ToJSON VersionObject where
  toJSON VersionObject {..} =
   _omitNulls
      [ "version" .= versionObjectVersion
      , "server" .= versionObjectServer
      ]


-- | Construct a value of type 'VersionObject' (by applying it's required fields, if any)
mkVersionObject
  :: VersionObject
mkVersionObject =
  VersionObject
  { versionObjectVersion = Nothing
  , versionObjectServer = Nothing
  }


-- * Enums


-- ** E'DeviceType

-- | Enum of 'Text'
data E'DeviceType
  = E'DeviceType'Ios -- ^ @"ios"@
  | E'DeviceType'Android -- ^ @"android"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'DeviceType where toJSON = A.toJSON . fromE'DeviceType
instance A.FromJSON E'DeviceType where parseJSON o = P.either P.fail (pure . P.id) . toE'DeviceType =<< A.parseJSON o
instance WH.ToHttpApiData E'DeviceType where toQueryParam = WH.toQueryParam . fromE'DeviceType
instance WH.FromHttpApiData E'DeviceType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'DeviceType
instance MimeRender MimeMultipartFormData E'DeviceType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'DeviceType' enum
fromE'DeviceType :: E'DeviceType -> Text
fromE'DeviceType = \case
  E'DeviceType'Ios -> "ios"
  E'DeviceType'Android -> "android"

-- | parse 'E'DeviceType' enum
toE'DeviceType :: Text -> P.Either String E'DeviceType
toE'DeviceType = \case
  "ios" -> P.Right E'DeviceType'Ios
  "android" -> P.Right E'DeviceType'Android
  s -> P.Left $ "toE'DeviceType: enum parse failure: " P.++ P.show s


